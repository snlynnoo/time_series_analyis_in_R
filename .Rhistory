lines(holt_pop$fitted, col=5, lwd=2)
legend("bottomright", c("Actual","3-WMA","3-EMA","SES", "Holt"), col=1:5, lwd=2, cex=0.5)
# dataset for MDA
install.packages('multilevel')
data(package='multilevel')
#
install.packages('nlme')
data(package='nlme')
#
install.packages('lme4')
data(package='lme4')
#
install.packages('MixedData')
data(package='MixedData')
install.packages('nlmixr')
data(package='nlmixr')
install.packages('mlmRev')
data(package='mlmRev')
#
install.packages('mlm')
data(package='mlm')
install.packages('lmerTest')
data(package='lmerTest')
install.packages('mlmRev')
data(package='mlmRev')
data (bdf, package='mlmRev')
bdf
data(package='lmerTest')
data (carrots, package='lmerTest')
carrots
View(carrots)
dim(carrots)
install.packages('mlmRev')
data(package='mlmRev')
data (Chem97 , package='mlmRev')
Chem
Chem97
View(Chem97)
summary(carrots)
data(package='lme4')
data (Arabidopsis, package='lme4')
Arabidopsis
View(Arabidopsis)
write.csv(carrots, "carrots.csv")
library(forcats)
install.packages('dynlm')
time = 1:length(sales)
time
library('dynlm')
season = seasonaldummy(Sales)
season = seasonaldummy(sales)
season = seasonaldummy(sales)
library(dynlm)
season = seasonaldummy(sales)
install.packages('forecast')
library(forecast)
library(forecast)
install.packages('forecast')
library(forecast)
acf(quakes)
acf(quakes)
acf(quakes, ylim=c(-1,1)) #ylim is optional for y-range
View(Earthquakes)
# Plotting annual TS plot # ts() : time series (in base library, no need to install)
# Transforming TS data types
quakes <- ts(Earthquakes$earthquakes, start = 1960, frequency = 1); quakes
# Easiest and simplest way to plot TS
plot(quakes)
# main = Chart title, xlab = X-axis Label, ylab = Y-axis Label
plot(quakes, main = "Annual Earthquakes 1960-2058", xlab = "Year", ylab = "Earthquakes Magnitude")
# Plotting quarterly TS plot
Sales <- ts(sales$Sales, frequency = 4) # here quarterly, so frequency = 4
plot(Sales, main = "Quarterly Sales", xlab = 'Year', ylab = 'Sales')
acf(quakes)
acf(quakes, ylim=c(-1,1)) #ylim is optional for y-range
Acf(quakes, ylim=c(-1,1))
Acf(quakes)
install.packages('forecast')
library(forecast)
acf(quakes)
Acf(quakes)
plot(quakes)
#library(uroot)
library(tseries)
adf.test(quakes)
plot(Sales)
Acf(Sales, ylim = c(-1,1), lag.max = 36)
ndiffs(quakes)
Acf(diff(quakes, 1))
adf.test(diff(quakes, 1))
ndiffs(quakes)
Acf(diff(quakes, 1))
adf.test(diff(quakes, 1))
Acf(diff)
Acf(diff(Sales, 4))
adf.test(Sales)
adf.test(diff(Sales),4)
adf.test(diff(Sales, 4))
adf.test(Sales)
adf.test(diff(Sales, 4))
beer <- ts(USABeerproduction$beerproductionusa, start = 1970, frequency = 12)
library(readr)
USABeerproduction <- read_csv("~/OneDrive/OneDrive - Asia Pacific University/Third Semester/02. Time Series/03. Teaching  Learning Materials-20221212/USABeerproduction.csv")
View(USABeerproduction)
beer <- ts(USABeerproduction$beerproductionusa, start = 1970, frequency = 12)
# start-which year to start, end-not defining means all, freq = 12 coz monthly
beer
# start-which year to start, end-not defining means all, freq = 12 coz monthly
View(beer)
plot(beer)
Acf(beer, lag.max = 50)
View(USABeerproduction)
plot(beer)
Acf(beer, lag.max = 50) #lag.max for four year data
adf.test(beer)
ndiffs(beer)
nsdiffs(beer)
ndiffs(beer) #for regular
nsdiffs(beer) #for seasonal
diff_beer <- diff(beer, 1) #for regular
diff12_diff_beer <- diff(diff_beer, 12) #for monthly seasonal
plot(beer)
plot(diff12_diff_beer)
adf.test(diff12_diff_beer)
Acf(diff12_diff_beer)
Acf(diff12_diff_beer, lag.max = 50)
ch.test(beer) #from Uroot
library('Uroot')
library('uroot')
ch.test(beer) #from Uroot
ch.test(diff12_diff_beer)
libray(forecast)
libray('forecast')
library('forecast')
beer
ses_beer <- ses(beer) #to auto optimize, just leave empty
ses_beer <- ses(beer, h=60, initial = 'simple') #h- forecast duration from function
autoplot(ses_beer)
summary(ses_beer)
holt_beer <- holt(beer, h=60, initial = 'simple')
autoplot(holt_beer)
holt_beer <- holt(beer, h=60)
autoplot(holt_beer)
summary(holt_beer)
plot(holt_beer, main = "Beer Production - Holt's Method Forecast", xlab = "year", ylab = "Production")
lines(holt_beer$fitted, col=2, lwd=2)
#Holt Winter's method
HW_beer <- hw(beer, h=60)
plot(HW_beer, main='Beer Production - Holt Winter Forecast', xlab = 'Year', ylab = "Production")
lines(HW_beer$fitted, col=2, lwd=2)
library('forecast')
Acf(beer, lag.max=50)
library('tseries')
adf.test(beer)
library('uroot')
ch.test(beer)
#how to convert monthly data into quarterly?
beer.qtr <-aggregate(beer, 4)
beer.qtr
library(forecast)
ma3 <- ma(quakes, 3, centre = T)
plot(ma3)
plot(quakes, main = "Annual Earthquateks Data", xlab = "Year", ylab = "Earthquakes")
# 3 period MA
ma3 <- ma(quakes, 3, centre = T)
# Inserting ma3 line to existing original quakes plot
lines(ma3, col=2, lwd=2)
# 10 period MA
ma10 <-ma(quakes, 10)
# Inserting ma10 line to existing original quakes plot
lines(ma10, col=3, lwd=2)
# Want to define "initial value" to be the "first value", pass "simple"
ses_quakes <- ses(quakes, initial = "simple")
lines(ses_quakes$fitted, col=4, lwd=2) # use $ sign and select "fitted"
# Adding labels to the plot
legend("topright", c("Acutal", "3-MA", "10-MA", "SES"), col = 1:4, lwd = 2, cex = 0.3)
legend("bottomright", c("Actual","3-WMA","3-EMA","SES", "Holt"), col=1:5, lwd=2, cex=0.5)
library(forecast)
# Plotting original quaked data
plot(quakes, main = "Annual Earthquateks Data", xlab = "Year", ylab = "Earthquakes")
# 3 period MA
ma3 <- ma(quakes, 3, centre = T) # order=3=period, if 5 period, pass 5.
# Inserting ma3 line to existing original quakes plot
lines(ma3, col=2, lwd=2) #col = color code, lwd = line thickness
# 10 period MA
ma10 <-ma(quakes, 10)
# Inserting ma10 line to existing original quakes plot
lines(ma10, col=3, lwd=2)
# If everything to be optimized, you just pass the data
ses_quakes <- ses(quakes)
# Want to define "initial value" to be the "first value", pass "simple"
ses_quakes <- ses(quakes, initial = "simple")
lines(ses_quakes$fitted, col=4, lwd=2) # use $ sign and select "fitted"
# Adding labels to the plot
legend("topright", c("Acutal", "3-MA", "10-MA", "SES"), col = 1:4, lwd = 2, cex = 0.5)
library(readxl)
Population_Malaysia <- read_excel("~/OneDrive/OneDrive - Asia Pacific University/Third Semester/02. Time Series/03. Teaching  Learning Materials-20221212/Population_Malaysia.xlsx")
View(Population_Malaysia)
# use $Total : we will use total population variable
#!required frequency since yearly data
library(TTR)
View(Population_Malaysia)
#install.packages("TTR")
Population <- ts(Population_Malaysia$Total, start = 1972)
library(TTR)
library(forecast)
plot(Population, main = "Malaysian Population 1970-2019", xlab = "Year", ylab = "Total Population")
# Weighted MV with 3 periods
wma3_pop <- WMA(Population, 3)
# Modified MV with 3 periods
ema3_pop <- EMA(Population, 3)
# Weighted MV with 3 periods
wma3_pop <- WMA(Population, 3) #from TTR package, period=3
# Modified MV with 3 periods
ema3_pop <- EMA(Population, 3)
# Simple Exponential Smoothing
ses_pop  <- ses(Population, Initial="simple") #from forecast package
# Linear Trend Model
linear_pop <- tslm(Population~., Population) #from forecast package
# Holt method
library('dyma')
# Holt method
# install.packages('dyma')
library('dyma')
# Holt method
install.packages('dyma')
library('dyma')
# Holt method
install.packages('dynlm')
library('dynlm')
# Holt method
# It can be used it from either forecast or stat package, same result.
holt_pop <- holt(Population, initial = "simple") #from forecast
# Adding lines to the original plot
lines(wma3_pop, col=2, lwd=2)
lines(ema3_pop, col=3, lwd=2)
lines(ses_pop$fitted, col=4, lwd=2)
lines(holt_pop$fitted, col=5, lwd=2)
legend("bottomright", c("Actual","3-WMA","3-EMA","SES", "Holt"), col=1:5, lwd=2, cex=0.5)
View(ses_pop)
library('dynlm')
View(Sales)
#you can also do with dynlm.
library('forecast')
View(sales)
time = 1:length(sales) #since there is no time column, we created
season = seasonal(Sales)
season = seasonal(sales)
season = seasonaldummy(Sales)
time = 1:length(Sales) #setting the time start at 1 until how many rows the dataset has
season = seasonaldummy(Sales) #adding dummy
#Ts Linear model
lmM <- tslm(Sales~time+season)
summary(lmM)
# Decomposition model
plot(Sales)
decomposition_additive <- decompose(Sales, type = "additive")
plot(decomposition_additive)
decomposition_additive$figure
#test: multiplicative model
decomposition_multiplicative <- decompose(Sales, type = "multiplicative")
decomposition_multiplicative$figure
plot(decomposition_multiplicative)
stlm <- stlm(Sales, s.window = 7)
summary(stlm)
summary(stl(Sales, s.window = 7))
#Split the data set into 80 % and 20%
view(Earthquakes)
#Split the data set into 80 % and 20%
View(Earthquakes)
quakes
training_quakes <- quakes[1:(length(quakes)*0.8)]
training_quakes
# 20% test set
testing_quakes <- quakes[1:(length(quakes)*0.8+1):(length(quakes)+1)]
# 20% test set
testing_quakes <- quakes[(length(quakes)*0.8+1):(length(quakes)+1)]
testing_quakes
# SES
library('forecast')
data(package='nlme')
data(machines, package='nlme')
data(Milk, package='nlme')
View(Milk)
dim(Milk)
data(Gasoline , package='nlme')
View(Gasoline )
?milk
??Milk
??Gasoline
??Gasoline
# 4
install.packages('MixedData')
data(package='MixedData')
data(package='mlmRev')
??Gasoline
data(package='mlmRev')
data(Wheat2 , package='mlmRev')
data(Wheat2 , package='nlme')
View(Wheat2)
data(Soybean , package='nlme')
View(Soybean)
dim(Wheat2)
data(Wafer , package='nlme')
View(Wafer)
data(Meat , package='nlme')
View(Meat)
??Meat
View(Wafer)
??Wafer
View(Milk)
data(Wheat , package='nlme')
View(Wheat)
??Wheat
View(Meat)
data(Fatigue , package='nlme')
View(Fatigue)
View(Gasoline)
??Gasoline
data(ergoStool , package='nlme')
View(ergoStool)
data(Gun , package='nlme')
View(Gun)
data(Oats , package='nlme')
View(Oats)
data(Oxide , package='nlme')
View(Oxide)
??Oxide
dim(Oxide)
data(Wheat2 , package='nlme')
View(Wheat2)
data(Wheat, package='nlme')
View(Wheat)
data(Wheat2, package='nlme')
View(Wheat2)
data(Tetracycline1, package='nlme')
View(Tetracycline1)
data(Tetracycline2, package='nlme')
View(Tetracycline2)
data(Gun, package='nlme')
View(Gun)
data(IGF, package='nlme')
View(IGF)
data(Ovary, package='nlme')
View(Ovary)
data(PBG, package='nlme')
View(PBG)
data(Nitrendipene, package='nlme')
View(Nitrendipene)
data(Rail, package='nlme')
View(Rail)
data(Remifentanil, package='nlme')
View(Remifentanil)
??Remifentanil
View(ergoStool)
data(Wafer, package='nlme')
View(Wafer)
??Wafer
data(Wheat, package='nlme')
View(Wheat)
data(Wheat2, package='nlme')
View(Wheat2)
??Wheat2
new_data <- Wheat2[sample(nrow(Wheat2), size = 1000, replace = F), ]
new_data <- Wheat2[sample(nrow(Wheat2), size = 1000, replace = TRUE), ]
View(new_data)
write.csv(new_data, "Wheat2.csv")
data(Wheat2, package='nlme')
??Wheat2
library('Forecast')
library('forecast')
tsdisplay(quakes)
tsdisplay(quakes)
tsdisplay(quakes)
adf.test(quakes)
library('tseries')
adf.test(quakes)
# will check how many times differencing required
ndiffs(quakes)
# the result is 0 => not recommended to differencing
tsdisplay(diff(quakes, 1)) #apply 1st differencing
# the result is 0 => not recommended to differencing
tsdisplay(diff(quakes, 1)) #apply 1st differencing
# ARIMA model from forecast package
quakes_arima011 <- arima(quakes, order = c(0,1,1)) #need to pass original data (not diff'ed data)
summary((quakes_arima011))
#to suggest the best suitable arima model
auto.arima(quakes)
auto.arima(quakes, trace = T) # trace back other models
quakes_arima101 <- arima(quakes, order = c(1, 0, 1))
accuracy(quakes_arima011)
accuracy(quakes_arima101)
Training set 0.1182301 5.887629 4.555481 -9.677964 26.5983 0.8407479 0.009220841
Training set 0.1182301 5.887629 4.555481 -9.677964 26.5983 0.8407479 0.009220841
avegrowth <- ts (Population_Malaysia$`Average annual population growth rate (%)`, start = 1970, end = 2017)
tsdisplay(avegrowth)
adf.test(avegrowth)
ndiff(avegrowth)
ndiffs(avegrowth)
tsdisplay(diff(avegrowth, 1))
auto.arima(avegrowth)
auto.arima(avegrowth, trace = T)
avegrowthpop <- ts (Population_Malaysia$`Average annual population growth rate (%)`, start = 1970, end = 2017)
tsdisplay(avegrowthpop)
adf.test(avegrowthpop) # => Not stationary
ndiffs(avegrowthpop) # Recommended once d=1
tsdisplay(diff(avegrowthpop, 1))
avegrowthpop_arima011 <- arima(avegrowthpop, order = c(0,1,1))
summary(avegrowthpop_arima011)
auto.arima(avegrowth, trace = T)
install.packages('lmtest')
install.packages("lmtest")
library('lmtest')
coeftest(avegrowthpop_arima011)
# to conduct Ljung Box test use forecast pack
checkresiduals(avegrowthpop_arima011)
checkresiduals(quakes_arima101)
checkresiduals(quakes_arima011)
# to conduct forecasts (forecast pack)
forecast(quakes_arima101, h= 5)
plot(forecast(quakes_arima101, h= 5))
lines(fitted(quakes_arima101), col=8, lwd=2)
checkresiduals(avegrowthpop_arima011)
??Wheat2
beer
ses_beer <- ses(beer, h=60, initial = 'simple') # h- forecast duration from function
#SES
library('forecast')
ses_beer <- ses(beer, h=60, initial = 'simple') # h- forecast duration from function
# On default, they will generate next 10 values, i.e, up to 1978-Oct if you want more specify 'h'
# Here 5 yr = 12 months x 5 yrs = 60, therefore, h=60 is provided in the function
# 'simple' mean Use the first value as initial value (13.092)
autoplot(ses_beer)
View(season)
summary(ses_beer)
#Holt's method
holt_beer <- holt(beer, h=60, initial = 'simple')
autoplot(holt_beer)
#Holt's method
holt_beer <- holt(beer, h=60, initial = 'simple')
autoplot(holt_beer)
holt_beer <- holt(beer, h=60)
autoplot(holt_beer)
summary(holt_beer)
summary(holt_beer)
plot(holt_beer, main = "Beer Production - Holt's Method Forecast", xlab = "year", ylab = "Production")
lines(holt_beer$fitted, col=2, lwd=2)
#Holt Winter's method
HW_beer <- hw(beer, h=60) #this is from forecast package, just used the optimized one
plot(HW_beer, main='Beer Production - Holt Winter Forecast', xlab = 'Year', ylab = "Production")
lines(HW_beer$fitted, col=2, lwd=2)
#Holt Winter's method
HW_beer <- hw(beer, h=60) #this is from forecast package, just used the optimized one
plot(HW_beer, main='Beer Production - Holt Winter Forecast', xlab = 'Year', ylab = "Production")
lines(HW_beer$fitted, col=2, lwd=2) # overlap the fitted model into the existing plot
summary(HW_beer)
#for multiplicative model
HW_beer_multiplicative <- hw(beer, h=60, seasonal = "multiplicative")
plot(HW_beer_multiplicative, main='Beer Production - Holt Winter Forecast', xlab = 'Year', ylab = "Production")
lines(HW_beer_multiplicative$fitted, col=2, lwd=2) # overlap the fitted model into the existing plot
summary(HW_beer_multiplicative)
# Decomposition model
# stl() - from stat package
# stlf() -from forecast package (they both are similar, just different in function names)
# Here, we will use from forecast package
stlf(beer, h=60)
# Decomposition model
# stl() - from stat package
# stlf() -from forecast package (they both are similar, just different in function names)
# Here, we will use from forecast package
decomposition_beer <- stlf(beer, h=60)
summary(decomposition_beer)
autoplot(decomposition_beer)
library('forecast')
tsdisplay(quakes) #
library('tseries')
adf.test(quakes)
# will check how many differencing is required
ndiffs(quakes)
tsdisplay(diff(quakes, 1)) #apply 1st differencing and plot ACF & PACF directly
# Building ARIMA model from forecast package
quakes_arima011 <- arima(quakes, order = c(0,1,1)) #need to pass original data (not diff'ed data)
summary((quakes_arima011))
summary(quakes_arima011)
# Building ARIMA model from forecast package
quakes_arima011 <- arima(quakes, order = c(0,1,1)) #need to pass original data (not diff'ed data)
# to track the coefficients
summary(quakes_arima011)
# to get suggestion for the best recommended arima model
auto.arima(quakes)
auto.arima(quakes, trace = T) # trace back other suggested models
# Builing ARIMA (1, 0, 1)
quakes_arima101 <- arima(quakes, order = c(1, 0, 1))
# will compare their perfomance between our model and auto.arima
accuracy(quakes_arima011)
accuracy(quakes_arima101)
# converting TS data (The question said within 1970 ~ 2017 only)
avegrowthpop <- ts (Population_Malaysia$`Average annual population growth rate (%)`, start = 1970, end = 2017)
# plotting ACF and PACF
tsdisplay(avegrowthpop)
# testing stationary
adf.test(avegrowthpop) # => Not stationary
# getting recommended number of diff.
ndiffs(avegrowthpop) # Recommended --> once --> d=1
# plotting ACF and PACF for transformed data directly
tsdisplay(diff(avegrowthpop, 1))
auto.arima(avegrowth, trace = T)
e
# Building ARIMA (0, 1, 1)
avegrowthpop_arima011 <- arima(avegrowthpop, order = c(0,1,1))
# to generate the unknown parameters/coefficient(s)
summary(avegrowthpop_arima011)
